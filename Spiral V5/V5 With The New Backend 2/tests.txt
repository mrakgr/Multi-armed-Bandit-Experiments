test1 - Does it run?:
inl a = 5
inl b = 10
a + b


Succ "15L
"
test2 - Does it run methods?:
met a () = 5
met b () = 10
a () + b ()


Succ
  "let rec method_14(): int64 =
    5L
and method_15(): int64 =
    10L
let (var_0: int64) = method_14()
let (var_1: int64) = method_15()
(var_0 + var_1)
"
test3 - Does this method case work?:
met a = 5
met b = 10
a + b


Succ
  "let rec method_14(): int64 =
    5L
and method_15(): int64 =
    10L
let (var_0: int64) = method_14()
let (var_1: int64) = method_15()
(var_0 + var_1)
"
test4 - Does the and pattern work correctly?:
met f (a, b) (c, d) = (a+c,b+d)
met q & (a, b) = 1,2
met w & (c, d) = 3,4
f q w


Succ
  "type Tuple0 =
    struct
    val mem_0: int64
    val mem_1: int64
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
let rec method_14(): Tuple0 =
    Tuple0(1L, 2L)
and method_15(): Tuple0 =
    Tuple0(3L, 4L)
and method_16((var_0: int64), (var_1: int64), (var_2: int64), (var_3: int64)): Tuple0 =
    let (var_4: int64) = (var_0 + var_2)
    let (var_5: int64) = (var_1 + var_3)
    Tuple0(var_4, var_5)
let (var_0: Tuple0) = method_14()
let (var_1: int64) = var_0.mem_0
let (var_2: int64) = var_0.mem_1
let (var_3: Tuple0) = method_15()
let (var_4: int64) = var_3.mem_0
let (var_5: int64) = var_3.mem_1
method_16((var_1: int64), (var_2: int64), (var_4: int64), (var_5: int64))
"
test5 - Does basic pattern matching work?:
inl f = function
    || .Add x y -> x + y
    || .Sub x y -> x - y
    || .Mult x y -> x * y
inl a = f .Add 1 2
inl b = f .Sub 1 2
inl c = f .Mult 1 2
a, b, c


Succ
  "type Tuple0 =
    struct
    val mem_0: int64
    val mem_1: int64
    val mem_2: int64
    new(arg_mem_0, arg_mem_1, arg_mem_2) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1; mem_2 = arg_mem_2}
    end
let rec method_14(): int64 =
    3L
and method_15(): int64 =
    -1L
and method_16(): int64 =
    2L
let (var_0: int64) = method_14()
let (var_1: int64) = method_15()
let (var_2: int64) = method_16()
Tuple0(var_0, var_1, var_2)
"
test6 - Does returning type level methods from methods work?:
met min n =
    met tes a =
        met b -> 
            met c ->
                met d -> a,b,c
    tes 1 2 (2.2,3,4.5)
min 10


Succ
  "type Env0 =
    struct
    val mem_a: int64
    val mem_b: int64
    val mem_c: Tuple3
    new(arg_mem_a, arg_mem_b, arg_mem_c) = {mem_a = arg_mem_a; mem_b = arg_mem_b; mem_c = arg_mem_c}
    end
and Env1 =
    struct
    val mem_a: int64
    new(arg_mem_a) = {mem_a = arg_mem_a}
    end
and Env2 =
    struct
    val mem_a: int64
    val mem_b: int64
    new(arg_mem_a, arg_mem_b) = {mem_a = arg_mem_a; mem_b = arg_mem_b}
    end
and Tuple3 =
    struct
    val mem_0: float
    val mem_1: int64
    val mem_2: float
    new(arg_mem_0, arg_mem_1, arg_mem_2) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1; mem_2 = arg_mem_2}
    end
let rec method_14(): Env0 =
    let (var_0: Env1) = method_15()
    let (var_1: int64) = var_0.mem_a
    let (var_2: Env2) = method_16((var_1: int64))
    let (var_3: int64) = var_2.mem_a
    let (var_4: int64) = var_2.mem_b
    method_17((var_3: int64), (var_4: int64))
and method_15(): Env1 =
    Env1(1L)
and method_16((var_0: int64)): Env2 =
    Env2(var_0, 2L)
and method_17((var_0: int64), (var_1: int64)): Env0 =
    Env0(var_0, var_1, Tuple3(2.200000, 3L, 4.500000))
method_14()
"
test7 - Do active patterns work?:
inl f op1 op2 op3 = function
    | !op1 (.Some, x) -> x
    | !op2 (.Some, x) -> x
    | !op3 (.Some, x) -> x

inl add = function
    | .Add -> .Some, inl x y -> x + y
    | _ -> .None
inl sub = function
    | .Sub -> .Some, inl x y -> x - y
    | _ -> .None
inl mult = function
    | .Mult -> .Some, inl x y -> x * y
    | _ -> .None

inl f = f add sub mult

inl a = f .Add 1 2
inl b = f .Sub 1 2
inl c = f .Mult 1 2
a, b, c


Succ
  "type Tuple0 =
    struct
    val mem_0: int64
    val mem_1: int64
    val mem_2: int64
    new(arg_mem_0, arg_mem_1, arg_mem_2) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1; mem_2 = arg_mem_2}
    end
Tuple0(3L, -1L, 2L)
"
test8 - Does the basic union type work?:
type option_int = 
    .Some, 1 
    .None

met x = box option_int .None
match x with
| .Some, x -> x
| .None -> 0


Succ
  "type Union0 =
    | Union0Case0 of Tuple1
    | Union0Case1
and Tuple1 =
    struct
    val mem_1: int64
    new(arg_mem_1) = {mem_1 = arg_mem_1}
    end
let rec method_18(): Union0 =
    Union0Case1
let (var_0: Union0) = method_18()
match var_0 with
| Union0Case0(var_1) ->
    var_1.mem_1
| Union0Case1 ->
    0L

"
test9 - Does the partial evaluator optimize unused match cases?:
type ab = 
    .A
    .B
inl ab = box ab
met x = (ab .A, ab .A, ab .A)
match x with
| .A, _, _ -> 1
| _, .A, _ -> 2
| _, _, .A -> 3
| _ -> 4


Succ
  "type Tuple0 =
    struct
    val mem_0: Union1
    val mem_1: Union1
    val mem_2: Union1
    new(arg_mem_0, arg_mem_1, arg_mem_2) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1; mem_2 = arg_mem_2}
    end
and Union1 =
    | Union1Case0
    | Union1Case1
let rec method_18(): Tuple0 =
    Tuple0(Union1Case0, Union1Case0, Union1Case0)
let (var_0: Tuple0) = method_18()
let (var_1: Union1) = var_0.mem_0
let (var_2: Union1) = var_0.mem_1
let (var_3: Union1) = var_0.mem_2
match var_1 with
| Union1Case0 ->
    1L
| Union1Case1 ->
    match var_2 with
    | Union1Case0 ->
        2L
    | Union1Case1 ->
        match var_3 with
        | Union1Case0 ->
            3L
        | Union1Case1 ->
            4L

"
test10 - The worst case for partially evaluated pattern matchers.:
type ab = 
    .A
    .B
inl ab = box ab
met x = (ab .A, ab .A, ab .A, ab .A)
match x with
| .A, .A, _, _ -> 1
| _, _, .A, .A -> 2
| .A, .B, .A, .B -> 3
| _ -> 4


Succ
  "type Tuple0 =
    struct
    val mem_0: Union1
    val mem_1: Union1
    val mem_2: Union1
    val mem_3: Union1
    new(arg_mem_0, arg_mem_1, arg_mem_2, arg_mem_3) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1; mem_2 = arg_mem_2; mem_3 = arg_mem_3}
    end
and Union1 =
    | Union1Case0
    | Union1Case1
let rec method_18(): Tuple0 =
    Tuple0(Union1Case0, Union1Case0, Union1Case0, Union1Case0)
let (var_0: Tuple0) = method_18()
let (var_1: Union1) = var_0.mem_0
let (var_2: Union1) = var_0.mem_1
let (var_3: Union1) = var_0.mem_2
let (var_4: Union1) = var_0.mem_3
match var_1 with
| Union1Case0 ->
    match var_2 with
    | Union1Case0 ->
        1L
    | Union1Case1 ->
        match var_3 with
        | Union1Case0 ->
            match var_4 with
            | Union1Case0 ->
                2L
            | Union1Case1 ->
                3L
        | Union1Case1 ->
            4L
| Union1Case1 ->
    match var_3 with
    | Union1Case0 ->
        match var_4 with
        | Union1Case0 ->
            2L
        | Union1Case1 ->
            4L
    | Union1Case1 ->
        4L

"
test1 - Do the nested patterns work on dynamic data?:
type a = (1,2)
type b = (1,a,a)
inl a,b = box a, box b
met x = b (1, a (2,3), a (4,5))
match x with
| _, (x, _), (_, y) -> x + y
| _, _, _ -> 0
| _ :: () -> 0


Succ
  "type Tuple0 =
    struct
    val mem_0: int64
    val mem_1: Tuple1
    val mem_2: Tuple1
    new(arg_mem_0, arg_mem_1, arg_mem_2) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1; mem_2 = arg_mem_2}
    end
and Tuple1 =
    struct
    val mem_0: int64
    val mem_1: int64
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
let rec method_20(): Tuple0 =
    Tuple0(1L, Tuple1(2L, 3L), Tuple1(4L, 5L))
let (var_0: Tuple0) = method_20()
let (var_1: int64) = var_0.mem_0
let (var_2: Tuple1) = var_0.mem_1
let (var_3: Tuple1) = var_0.mem_2
let (var_4: int64) = var_2.mem_0
let (var_5: int64) = var_2.mem_1
let (var_6: int64) = var_3.mem_0
let (var_7: int64) = var_3.mem_1
(var_4 + var_7)
"
test12 - Does recursive pattern matching work on static data?:
inl rec p = function
    | .Some, x -> p x
    | .None -> 0
p (.Some, .None)


Succ "0L
"
test13 - A more complex interpreter example on static data.:
type expr x = 
    .V, x
    .Add, expr x, expr x
    .Mult, expr x, expr x
inl int_expr = box (expr int64)
inl v x = int_expr (.V, x)
inl add a b = int_expr (.Add, a, b)
inl mult a b = int_expr (.Mult, a, b)
inl a = add (v 1) (v 2)
inl b = add (v 3) (v 4)
inl c = mult a b
inl rec interpreter_static x = 
    match x with
    | .V, x -> x
    | .Add, a, b -> interpreter_static a + interpreter_static b
    | .Mult, a, b -> interpreter_static a * interpreter_static b
interpreter_static c


Succ "21L
"
test14 - Does recursive pattern matching work on partially static data?:
type expr x = 
    .V, x
    .Add, expr x, expr x
    .Mult, expr x, expr x
inl int_expr = box (expr int64)
inl v x = int_expr (.V, x)
inl add a b = int_expr (.Add, a, b)
inl mult a b = int_expr (.Mult, a, b)
met a = add (v 1) (v 2)
met b = add (v 3) (v 4)
inl c = mult a b
met rec inter x = 
    match x with
    | .V, x -> x
    | .Add, a, b -> inter a + inter b
    | .Mult, a, b -> inter a * inter b
    : int64
inter c


Succ
  "type Rec0 =
    | Rec0Case0 of Tuple2
    | Rec0Case1 of Tuple3
    | Rec0Case2 of Tuple1
and Tuple1 =
    struct
    val mem_1: int64
    new(arg_mem_1) = {mem_1 = arg_mem_1}
    end
and Tuple2 =
    struct
    val mem_1: Rec0
    val mem_2: Rec0
    new(arg_mem_1, arg_mem_2) = {mem_1 = arg_mem_1; mem_2 = arg_mem_2}
    end
and Tuple3 =
    struct
    val mem_1: Rec0
    val mem_2: Rec0
    new(arg_mem_1, arg_mem_2) = {mem_1 = arg_mem_1; mem_2 = arg_mem_2}
    end
let rec method_19(): Rec0 =
    Rec0Case0(Tuple2(Rec0Case2(Tuple1(1L)), Rec0Case2(Tuple1(2L))))
and method_20(): Rec0 =
    Rec0Case0(Tuple2(Rec0Case2(Tuple1(3L)), Rec0Case2(Tuple1(4L))))
and method_21((var_0: Rec0), (var_1: Rec0)): int64 =
    let (var_2: int64) = method_22((var_0: Rec0))
    let (var_3: int64) = method_22((var_1: Rec0))
    (var_2 * var_3)
and method_22((var_0: Rec0)): int64 =
    match var_0 with
    | Rec0Case0(var_1) ->
        let (var_4: Rec0) = var_1.mem_1
        let (var_5: Rec0) = var_1.mem_2
        let (var_6: int64) = method_22((var_4: Rec0))
        let (var_7: int64) = method_22((var_5: Rec0))
        (var_6 + var_7)
    | Rec0Case1(var_2) ->
        let (var_8: Rec0) = var_2.mem_1
        let (var_9: Rec0) = var_2.mem_2
        let (var_10: int64) = method_22((var_8: Rec0))
        let (var_11: int64) = method_22((var_9: Rec0))
        (var_10 * var_11)
    | Rec0Case2(var_3) ->
        var_3.mem_1
let (var_0: Rec0) = method_19()
let (var_1: Rec0) = method_20()
method_21((var_0: Rec0), (var_1: Rec0))
"
test15 - Does basic .NET interop work?:
inl system = load_assembly .mscorlib
inl builder_type = ."System.Text.StringBuilder" |> system 
inl b = builder_type ("Qwe", 128i32)
inl a x =
    b .Append x |> ignore
    b .AppendLine () |> ignore
a 123
a 123i16
a "qwe"
inl str = b.ToString()
inl console = ."System.Console" |> system
console .Write str |> ignore

inl dictionary_type = ."System.Collections.Generic.Dictionary`2" |> system
inl dict = dictionary_type(int64, int64)(128i32)
dict.Add(1,2) |> ignore
dict.get_Item 1


Succ
  "let (var_0: System.Text.StringBuilder) = System.Text.StringBuilder("Qwe", 128)
let (var_1: System.Text.StringBuilder) = var_0.Append(123L)
let (var_2: System.Text.StringBuilder) = var_0.AppendLine()
let (var_3: System.Text.StringBuilder) = var_0.Append(123s)
let (var_4: System.Text.StringBuilder) = var_0.AppendLine()
let (var_5: System.Text.StringBuilder) = var_0.Append("qwe")
let (var_6: System.Text.StringBuilder) = var_0.AppendLine()
let (var_7: string) = var_0.ToString()
System.Console.Write(var_7)
let (var_8: System.Collections.Generic.Dictionary<int64,int64>) = System.Collections.Generic.Dictionary<int64,int64>(128)
var_8.Add(1L, 2L)
var_8.get_Item(1L)
"
test16 - Do var union types work?:
type t = 
    int64
    float64
if dyn true then box t 0
else box t 0.0


Succ
  "type Union0 =
    | Union0Case0 of int64
    | Union0Case1 of float
let (var_0: bool) = true
if var_0 then
    Union0Case0(0L)
else
    Union0Case1(0.000000)

"
test17 - Do modules work?:
inl m =
    inl x = 2
    inl y = 3.4
    inl z = "123"
    module (x,(y),z)
m.x, m.y, m.z


Succ
  "type Tuple0 =
    struct
    val mem_0: int64
    val mem_1: float
    val mem_2: string
    new(arg_mem_0, arg_mem_1, arg_mem_2) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1; mem_2 = arg_mem_2}
    end
Tuple0(2L, 3.400000, "123")
"
test18 - Do arrays and references work?:
inl a = ref 0
a := 5
a() |> ignore

inl a = ref () // Is not supposed to be printed due to being unit.
a := ()
a()

inl a = ref <| term_cast (inl a, b -> a + b) (int64,int64)
a := term_cast (inl a, b -> a * b) (int64,int64)
a() |> ignore

inl a = array_create 10 int64
a 3 <- 2
a 3 |> ignore

inl a = array_create 3 id // Is supposed to be unit and not printed.
a 1 <- id
a 1 |> ignore


Succ
  "let rec method_14 ((var_0: int64), (var_1: int64)): int64 =
    (var_0 + var_1)
and method_15 ((var_0: int64), (var_1: int64)): int64 =
    (var_0 * var_1)
let (var_0: (int64 ref)) = (ref 0L)
var_0 := 5L
let (var_1: int64) = (!var_0)
let (var_4: (int64 * int64 -> int64)) = method_14
let (var_5: ((int64 * int64 -> int64) ref)) = (ref var_4)
let (var_8: (int64 * int64 -> int64)) = method_15
var_5 := var_8
let (var_9: (int64 * int64 -> int64)) = (!var_5)
let (var_10: (int64 [])) = Array.zeroCreate<int64> (System.Convert.ToInt32(10L))
var_10.[int32 3L] <- 2L
let (var_11: int64) = var_10.[int32 3L]

"
test19 - Does term casting for functions work?:
inl add a b (c, (d, e), f) = a + b + c + d + e + f
inl f = term_cast (add 8 (dyn 7)) (int64,(int64,int64),int64)
f (1,(2,5),3)


Succ
  "type Tuple0 =
    struct
    val mem_0: int64
    val mem_1: int64
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
let rec method_14 ((var_0: int64)) ((var_1: int64), (var_2: Tuple0), (var_3: int64)): int64 =
    let (var_4: int64) = var_2.mem_0
    let (var_5: int64) = var_2.mem_1
    let (var_6: int64) = (8L + var_0)
    let (var_7: int64) = (var_6 + var_1)
    let (var_8: int64) = (var_7 + var_4)
    let (var_9: int64) = (var_8 + var_5)
    (var_9 + var_3)
let (var_0: int64) = 7L
let (var_4: (int64 * Tuple0 * int64 -> int64)) = method_14((var_0: int64))
var_4(1L, Tuple0(2L, 5L), 3L)
"
test20 - Does pattern matching on union non-tuple types work? Do type annotation patterns work?:
type t = 
    int64
    float64
inl x = box t 3.5
match x with
| q : int64 -> x * x
| q : float64 -> x + x


Succ "7.000000
"
test21 - Does defining user operators work?:
inl (.+) a b = a + b
inl x = 2 * 22 .+ 33

inl f op a b = op a b
f (*) 2 x


Succ "154L
"
test22 - Do unary operators work?:
inl t1 x = -x
inl t3 x = .(x)
t1 2.2, t3 "asd"


Succ
  "type Tuple0 =
    struct
    val mem_0: float
    new(arg_mem_0) = {mem_0 = arg_mem_0}
    end
Tuple0(-2.200000)
"
test23 - Do when and as patterns work?:
inl f = function
    | a,b,c as q when a < 10 -> q
    | _ -> 0,0,0
f (1,2,3)


Succ
  "type Tuple0 =
    struct
    val mem_0: int64
    val mem_1: int64
    val mem_2: int64
    new(arg_mem_0, arg_mem_1, arg_mem_2) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1; mem_2 = arg_mem_2}
    end
Tuple0(1L, 2L, 3L)
"
test24 - Do literal pattern matchers work? Does partial evaluation of equality work?:
inl f x = 
    match x with
    | 0 -> "0", x
    | 1 -> "1", x
    | false -> "false", x
    | true -> "true", x
    | "asd" -> "asd", x
    | 1i8 -> "1i8", x
    | 5.5 -> "5.5", x
    | .5.5 -> ".5.5", x
    | .23u32 -> ".23u32",x
    | _ -> "unknown", x

f 0, f 1, f false, f true, f "asd", f 1i8,
f 5.5, f 5f64, f .5.5, f .23u32


Succ
  "type Tuple0 =
    struct
    val mem_0: string
    val mem_1: int64
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
and Tuple1 =
    struct
    val mem_0: string
    val mem_1: bool
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
and Tuple2 =
    struct
    val mem_0: string
    val mem_1: string
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
and Tuple3 =
    struct
    val mem_0: string
    val mem_1: int8
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
and Tuple4 =
    struct
    val mem_0: string
    val mem_1: float
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
and Tuple5 =
    struct
    val mem_0: string
    new(arg_mem_0) = {mem_0 = arg_mem_0}
    end
and Tuple6 =
    struct
    val mem_0: string
    new(arg_mem_0) = {mem_0 = arg_mem_0}
    end
and Tuple7 =
    struct
    val mem_0: Tuple0
    val mem_1: Tuple0
    val mem_2: Tuple1
    val mem_3: Tuple1
    val mem_4: Tuple2
    val mem_5: Tuple3
    val mem_6: Tuple4
    val mem_7: Tuple4
    val mem_8: Tuple5
    val mem_9: Tuple6
    new(arg_mem_0, arg_mem_1, arg_mem_2, arg_mem_3, arg_mem_4, arg_mem_5, arg_mem_6, arg_mem_7, arg_mem_8, arg_mem_9) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1; mem_2 = arg_mem_2; mem_3 = arg_mem_3; mem_4 = arg_mem_4; mem_5 = arg_mem_5; mem_6 = arg_mem_6; mem_7 = arg_mem_7; mem_8 = arg_mem_8; mem_9 = arg_mem_9}
    end
Tuple7(Tuple0("0", 0L), Tuple0("1", 1L), Tuple1("false", false), Tuple1("true", true), Tuple2("asd", "asd"), Tuple3("1i8", 1y), Tuple4("5.5", 5.500000), Tuple4("unknown", 5.000000), Tuple5(".5.5"), Tuple6(".23u32"))
"
test25 - Does the tuple cons pattern work?:
inl f = function | x1 :: x2 :: x3 :: xs -> 3 | x1 :: x2 :: xs -> 2 | x1 :: xs -> 1 | () -> 0

f (), f (1 :: ()), f (1,2)


Succ
  "type Tuple0 =
    struct
    val mem_0: int64
    val mem_1: int64
    val mem_2: int64
    new(arg_mem_0, arg_mem_1, arg_mem_2) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1; mem_2 = arg_mem_2}
    end
Tuple0(0L, 1L, 2L)
"
test26 - Does tuple map work? This also tests rev and foldl.:
Tuple.map (inl x -> x * 2) (1,2,3)


Succ
  "type Tuple0 =
    struct
    val mem_0: int64
    val mem_1: int64
    val mem_2: int64
    new(arg_mem_0, arg_mem_1, arg_mem_2) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1; mem_2 = arg_mem_2}
    end
Tuple0(2L, 4L, 6L)
"
test27 - Do tuple zip and unzip work?:
inl j = 2,3.3
inl k = 4.4,55
inl l = 66,77
inl m = 88,99
inl n = 123,456
Tuple.zip ((j,k),(l,m),n) |> Tuple.unzip


Succ
  "type Tuple0 =
    struct
    val mem_0: int64
    val mem_1: float
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
and Tuple1 =
    struct
    val mem_0: float
    val mem_1: int64
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
and Tuple2 =
    struct
    val mem_0: Tuple0
    val mem_1: Tuple1
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
and Tuple3 =
    struct
    val mem_0: int64
    val mem_1: int64
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
and Tuple4 =
    struct
    val mem_0: Tuple3
    val mem_1: Tuple3
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
and Tuple5 =
    struct
    val mem_0: Tuple2
    val mem_1: Tuple4
    val mem_2: Tuple3
    new(arg_mem_0, arg_mem_1, arg_mem_2) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1; mem_2 = arg_mem_2}
    end
Tuple5(Tuple2(Tuple0(2L, 3.300000), Tuple1(4.400000, 55L)), Tuple4(Tuple3(66L, 77L), Tuple3(88L, 99L)), Tuple3(123L, 456L))
"
test28 - Does string indexing work?:
inl console = mscorlib ."System.Console"
inl a = "qwe"
inl b = console.ReadLine()
a(0),b(0)


Succ
  "type Tuple0 =
    struct
    val mem_0: char
    val mem_1: char
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
let (var_0: string) = System.Console.ReadLine()
let (var_1: char) = var_0.[int32 0L]
Tuple0('q', var_1)
"
test29 - Does pattern matching work redux?:
type t = 
    int64, int64
    int64

inl x = (1,1) |> box t |> dyn
match x with
| a,b -> 0
| c -> c


Succ
  "type Union0 =
    | Union0Case0 of int64
    | Union0Case1 of Tuple1
and Tuple1 =
    struct
    val mem_0: int64
    val mem_1: int64
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
let (var_0: Union0) = Union0Case1(Tuple1(1L, 1L))
match var_0 with
| Union0Case0(var_1) ->
    var_1
| Union0Case1(var_2) ->
    let (var_3: int64) = var_2.mem_0
    let (var_4: int64) = var_2.mem_1
    0L

"
test30 - Do recursive algebraic datatypes work?:
type List x =
    .ListCons, (x, List x)
    .ListNil

inl t = box (List int64)
inl nil = t .ListNil
inl cons x xs = t (.ListCons, (x, xs))

met rec sum (!dyn s) l = 
    match l with
    | .ListCons, (x, xs) -> sum (s + x) xs
    | .ListNil -> s
    : int64

nil |> cons 3 |> cons 2 |> cons 1 |> dyn |> sum 0


Succ
  "type Rec0 =
    | Rec0Case0 of Tuple2
    | Rec0Case1
and Tuple1 =
    struct
    val mem_0: int64
    val mem_1: Rec0
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
and Tuple2 =
    struct
    val mem_1: Tuple1
    new(arg_mem_1) = {mem_1 = arg_mem_1}
    end
let rec method_18((var_0: Rec0), (var_1: int64)): int64 =
    match var_0 with
    | Rec0Case0(var_2) ->
        let (var_4: Tuple1) = var_2.mem_1
        let (var_5: int64) = var_4.mem_0
        let (var_6: Rec0) = var_4.mem_1
        let (var_7: int64) = (var_1 + var_5)
        method_18((var_6: Rec0), (var_7: int64))
    | Rec0Case1 ->
        var_1
let (var_0: Rec0) = Rec0Case0(Tuple2(Tuple1(1L, Rec0Case0(Tuple2(Tuple1(2L, Rec0Case0(Tuple2(Tuple1(3L, Rec0Case1)))))))))
let (var_1: int64) = 0L
method_18((var_0: Rec0), (var_1: int64))
"
test31 - Does passing types into types work?:
type a = 
    .A, (int64, int64)
    .B, string

type b = 
    a
    .Hello
(.A, (2,3)) |> box a |> dyn |> box b


Succ
  "type Union0 =
    | Union0Case0 of Tuple2
    | Union0Case1 of Tuple4
and Tuple1 =
    struct
    val mem_0: int64
    val mem_1: int64
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
and Tuple2 =
    struct
    val mem_1: Tuple1
    new(arg_mem_1) = {mem_1 = arg_mem_1}
    end
and Union3 =
    | Union3Case0 of Tuple2
    | Union3Case1 of Tuple4
    | Union3Case2
and Tuple4 =
    struct
    val mem_1: string
    new(arg_mem_1) = {mem_1 = arg_mem_1}
    end
let (var_0: Union0) = Union0Case0(Tuple2(Tuple1(2L, 3L)))
match var_0 with
| Union0Case0(var_1) ->
    let (var_3: Tuple1) = var_1.mem_1
    Union3Case0(Tuple2(var_3))
| Union0Case1(var_2) ->
    let (var_4: string) = var_2.mem_1
    Union3Case1(Tuple4(var_4))

"
test32 - Do the .NET methods work inside methods?:
inl to_int64 = mscorlib ."System.Convert" .ToInt64
met f = to_int64 (dyn 'a')
f


Succ
  "let rec method_14(): int64 =
    let (var_0: char) = 'a'
    System.Convert.ToInt64(var_0)
method_14()
"
test33 - Does a simple loop have superlinear scaling?:
inl rec loop = function
    | i when i > 0 -> loop (i-1)
    | 0 -> ()
loop 50000


Succ "
"
test34 - Does a simple stackified function work?:
inl a = dyn 1
inl b = dyn 2
inl add c d = a + b + c + d
met f g c d = g c d
f (stack add) (dyn 3) (dyn 4)


Succ
  "type EnvStack0 =
    struct
    val mem_0: int64
    val mem_1: int64
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
let rec method_14((var_0: int64), (var_1: int64), (var_2: EnvStack0)): int64 =
    let (var_3: int64) = var_2.mem_0
    let (var_4: int64) = var_2.mem_1
    let (var_5: int64) = (var_3 + var_4)
    let (var_6: int64) = (var_5 + var_0)
    (var_6 + var_1)
let (var_0: int64) = 1L
let (var_1: int64) = 2L
let (var_2: EnvStack0) = EnvStack0((var_0: int64), (var_1: int64))
let (var_3: int64) = 3L
let (var_4: int64) = 4L
method_14((var_3: int64), (var_4: int64), (var_2: EnvStack0))
"
test35 - Does case on union types with recursive types work properly?:
type List x = 
    .Nil
    .Cons, (int64, List x)

type Res =
    int64
    int64, int64
    List int64

match box Res 1 |> dyn with
| x : int64 -> 1
| (a, b) as x -> 2
| _ -> 3


Succ
  "type Union0 =
    | Union0Case0 of int64
    | Union0Case1 of Tuple3
    | Union0Case2 of Rec1
and Rec1 =
    | Rec1Case0 of Tuple4
    | Rec1Case1
and Tuple2 =
    struct
    val mem_0: int64
    val mem_1: Rec1
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
and Tuple3 =
    struct
    val mem_0: int64
    val mem_1: int64
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
and Tuple4 =
    struct
    val mem_1: Tuple2
    new(arg_mem_1) = {mem_1 = arg_mem_1}
    end
let (var_0: Union0) = Union0Case0(1L)
match var_0 with
| Union0Case0(var_1) ->
    1L
| Union0Case1(var_2) ->
    let (var_4: int64) = var_2.mem_0
    let (var_5: int64) = var_2.mem_1
    2L
| Union0Case2(var_3) ->
    match var_3 with
    | Rec1Case0(var_6) ->
        let (var_8: Tuple2) = var_6.mem_1
        let (var_9: int64) = var_8.mem_0
        let (var_10: Rec1) = var_8.mem_1
        2L
    | Rec1Case1 ->
        3L

"
test36 - Does a simple heapified function work?:
inl a = dyn 1
inl b = dyn 2
inl add c d = a + b + c + d
met f g c d = g c d
f (heap add) (dyn 3) (dyn 4)


Succ
  "type EnvHeap0 =
    {
    mem_0: int64
    mem_1: int64
    }
let rec method_14((var_0: int64), (var_1: int64), (var_2: EnvHeap0)): int64 =
    let (var_3: int64) = var_2.mem_0
    let (var_4: int64) = var_2.mem_1
    let (var_5: int64) = (var_3 + var_4)
    let (var_6: int64) = (var_5 + var_0)
    (var_6 + var_1)
let (var_0: int64) = 1L
let (var_1: int64) = 2L
let (var_2: EnvHeap0) = ({mem_0 = (var_0: int64); mem_1 = (var_1: int64)} : EnvHeap0)
let (var_3: int64) = 3L
let (var_4: int64) = 4L
method_14((var_3: int64), (var_4: int64), (var_2: EnvHeap0))
"
test37 - Does a simple heapified module work?:
inl m = heap {a=dyn 1; b=dyn 2}
inl add c d = 
    inl {a b} = m
    a + b + c + d
met f g c d = g c d
f (heap add) (dyn 3) (dyn 4)


Succ
  "type EnvHeap0 =
    {
    mem_0: int64
    mem_1: int64
    }
let rec method_14((var_0: int64), (var_1: int64), (var_2: EnvHeap0)): int64 =
    let (var_3: int64) = var_2.mem_0
    let (var_4: int64) = var_2.mem_1
    let (var_5: int64) = (var_3 + var_4)
    let (var_6: int64) = (var_5 + var_0)
    (var_6 + var_1)
let (var_0: int64) = 1L
let (var_1: int64) = 2L
let (var_2: EnvHeap0) = ({mem_0 = (var_0: int64); mem_1 = (var_1: int64)} : EnvHeap0)
let (var_3: int64) = 3L
let (var_4: int64) = 4L
method_14((var_3: int64), (var_4: int64), (var_2: EnvHeap0))
"
test38 - Is type constructor of an int64 an int64?:
box int64 (dyn 1)


Succ "1L
"
test39 - Does a nested heapified module work?:
inl m = heap {a=dyn 1; b=dyn 2; c' = {q=dyn 3; w=dyn 4}}
inl m' = {m.c' with q=dyn 6}
inl add c d = 
    inl {a b {c' with q w}} = m
    a + b + c + d + q + w
met f g c d = g c d
f (heap add) (dyn 3) (dyn 4)


Succ
  "type EnvHeap0 =
    {
    mem_0: int64
    mem_1: int64
    mem_2: int64
    mem_3: int64
    }
let rec method_14((var_0: int64), (var_1: int64), (var_2: EnvHeap0)): int64 =
    let (var_3: int64) = var_2.mem_0
    let (var_4: int64) = var_2.mem_1
    let (var_5: int64) = var_2.mem_2
    let (var_6: int64) = var_2.mem_3
    let (var_7: int64) = (var_3 + var_4)
    let (var_8: int64) = (var_7 + var_0)
    let (var_9: int64) = (var_8 + var_1)
    let (var_10: int64) = (var_9 + var_5)
    (var_10 + var_6)
let (var_0: int64) = 1L
let (var_1: int64) = 2L
let (var_2: int64) = 3L
let (var_3: int64) = 4L
let (var_4: EnvHeap0) = ({mem_0 = (var_0: int64); mem_1 = (var_1: int64); mem_2 = (var_2: int64); mem_3 = (var_3: int64)} : EnvHeap0)
let (var_5: int64) = var_4.mem_0
let (var_6: int64) = var_4.mem_1
let (var_7: int64) = var_4.mem_2
let (var_8: int64) = var_4.mem_3
let (var_9: int64) = 6L
let (var_10: EnvHeap0) = ({mem_0 = (var_5: int64); mem_1 = (var_6: int64); mem_2 = (var_9: int64); mem_3 = (var_8: int64)} : EnvHeap0)
let (var_11: int64) = 3L
let (var_12: int64) = 4L
method_14((var_11: int64), (var_12: int64), (var_4: EnvHeap0))
"
test40 - Does this compile into just one method? Are the arguments reversed in the method call?:
met rec f a b =
    if dyn true then f b a
    else a + b
    : 0
f (dyn 1) (dyn 2)


Succ
  "let rec method_14((var_0: int64), (var_1: int64)): int64 =
    let (var_2: bool) = true
    if var_2 then
        method_14((var_1: int64), (var_0: int64))
    else
        (var_0 + var_1)
let (var_0: int64) = 1L
let (var_1: int64) = 2L
method_14((var_0: int64), (var_1: int64))
"
test41 - Does a nested heapified module work?:
inl m = heap {a=dyn 1; b=dyn 2; c' = stack {q=dyn 3; w=dyn 4}}
inl m' = {m.c' with q=dyn 9}
inl add c d = 
    inl {a b {c' with q w}} = m'
    a + b + c + d + q + w
met f g c d = g c d
f (heap add) (dyn 3) (dyn 4) // 23


Succ
  "type EnvHeap0 =
    {
    mem_0: int64
    mem_1: int64
    mem_2: EnvStack1
    }
and EnvStack1 =
    struct
    val mem_0: int64
    val mem_1: int64
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
let rec method_14((var_0: int64), (var_1: int64), (var_2: EnvHeap0)): int64 =
    let (var_3: int64) = var_2.mem_0
    let (var_4: int64) = var_2.mem_1
    let (var_5: EnvStack1) = var_2.mem_2
    let (var_6: int64) = var_5.mem_0
    let (var_7: int64) = var_5.mem_1
    let (var_8: int64) = (var_3 + var_4)
    let (var_9: int64) = (var_8 + var_0)
    let (var_10: int64) = (var_9 + var_1)
    let (var_11: int64) = (var_10 + var_6)
    (var_11 + var_7)
let (var_0: int64) = 1L
let (var_1: int64) = 2L
let (var_2: int64) = 3L
let (var_3: int64) = 4L
let (var_4: EnvStack1) = EnvStack1((var_2: int64), (var_3: int64))
let (var_5: EnvHeap0) = ({mem_0 = (var_0: int64); mem_1 = (var_1: int64); mem_2 = (var_4: EnvStack1)} : EnvHeap0)
let (var_6: int64) = var_5.mem_0
let (var_7: int64) = var_5.mem_1
let (var_8: EnvStack1) = var_5.mem_2
let (var_9: int64) = var_8.mem_0
let (var_10: int64) = var_8.mem_1
let (var_11: int64) = 9L
let (var_12: EnvStack1) = EnvStack1((var_11: int64), (var_10: int64))
let (var_13: EnvHeap0) = ({mem_0 = (var_6: int64); mem_1 = (var_7: int64); mem_2 = (var_12: EnvStack1)} : EnvHeap0)
let (var_14: int64) = 3L
let (var_15: int64) = 4L
method_14((var_14: int64), (var_15: int64), (var_13: EnvHeap0))
"
test42 - Do partial active patterns work?:
inl f x on_fail on_succ =
    match x with
    | x : int64 -> on_succ (x,"is_int64")
    | x : int32 -> on_succ (x,"is_int32",x*x)
    | x -> on_fail()

inl m m1 = function
    | @m1 (q,w,e) -> q,w,e
    | @m1 (q,w) -> q,w
    | @m1 q -> q
    | x -> error_type "The call to m1 failed."

m f 2


Succ
  "type Tuple0 =
    struct
    val mem_0: int64
    val mem_1: string
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
Tuple0(2L, "is_int64")
"
test43 - Do the Array constructors work?:
open Array

empty int64, singleton 2.2


Succ
  "type Tuple0 =
    struct
    val mem_0: (int64 [])
    val mem_1: (float [])
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
let (var_0: (int64 [])) = Array.zeroCreate<int64> (System.Convert.ToInt32(0L))
let (var_1: (float [])) = Array.zeroCreate<float> (System.Convert.ToInt32(1L))
var_1.[int32 0L] <- 2.200000
Tuple0(var_0, var_1)
"
test44 - Do or extension active patterns work?:
inl f x on_fail on_succ =
    match x with
    | .tup, 4, x -> on_succ x // This one does not get triggered due to not being in m
    | .tup, 3, x -> on_succ x
    | .tup, 2, x -> on_succ x
    | .var, x -> on_succ ("is_var",x)
    | _ -> on_fail()

inl m m1 = function
    | #m1 (x,_,_ | x,_ | x) -> x
    | _ -> error_type "The call to m1 failed."

// Tuple4(Tuple1("is_var", true), 2.200000f, "a", Tuple3("is_var", Tuple2(1L, 2L, 3L, 4L)))
m f true, m f (2.2,3.3), m f ("a","b","c"), m f (1,2,3,4)


Succ
  "type Tuple0 =
    struct
    val mem_0: string
    val mem_1: bool
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
and Tuple1 =
    struct
    val mem_0: int64
    val mem_1: int64
    val mem_2: int64
    val mem_3: int64
    new(arg_mem_0, arg_mem_1, arg_mem_2, arg_mem_3) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1; mem_2 = arg_mem_2; mem_3 = arg_mem_3}
    end
and Tuple2 =
    struct
    val mem_0: string
    val mem_1: Tuple1
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
and Tuple3 =
    struct
    val mem_0: Tuple0
    val mem_1: float
    val mem_2: string
    val mem_3: Tuple2
    new(arg_mem_0, arg_mem_1, arg_mem_2, arg_mem_3) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1; mem_2 = arg_mem_2; mem_3 = arg_mem_3}
    end
Tuple3(Tuple0("is_var", true), 2.200000, "a", Tuple2("is_var", Tuple1(1L, 2L, 3L, 4L)))
"
test45 - Do `type` and `when` patterns work with combination extension patterns?:
inl f x on_fail on_succ =
    match x with
    | _, _, x -> on_succ x
    | _, x -> on_succ x

inl m m1 = function
    | #m1 ((a,b,c): (int64,int64,int64)) -> "is_int64_int64_int64"
    | #m1 ((a,b): (int64,int64)) -> "is_int64_int64"
    | #m1 (x : bool) -> "is_bool"
    | #m1 x -> "is_x"

inl m' n m1 = function
    | #m1 ((a,b,c): (int64,int64,int64) when n > 5) -> "is_int64_int64_int64, n > 5"
    | #m1 ((a,b): (int64,int64) when n > 5) -> "is_int64_int64, n > 5"
    | #m1 ((a,b): (int64,int64) when n <= 5) -> "is_int64_int64, n <= 5"
    | _ -> "???"

// Tuple5("is_int64_int64", "is_bool", "is_int64_int64, n > 5", "is_int64_int64, n <= 5", "???")
m f (1,1), m f true, m' 6 f (2,2), m' 5 f (2,2), m' 1 f 123.456


Succ
  "type Tuple0 =
    struct
    val mem_0: string
    val mem_1: string
    val mem_2: string
    val mem_3: string
    val mem_4: string
    new(arg_mem_0, arg_mem_1, arg_mem_2, arg_mem_3, arg_mem_4) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1; mem_2 = arg_mem_2; mem_3 = arg_mem_3; mem_4 = arg_mem_4}
    end
Tuple0("is_int64_int64", "is_bool", "is_int64_int64, n > 5", "is_int64_int64, n <= 5", "???")
"
test46 - Does the module pattern work?:
inl f {a b c} = a + b + c
inl x =
    {
    a=1
    b=2
    c=3
    }

f {x with a = 4}


Succ "9L
"
test47 - Does the nested module pattern work?:
inl f {name {p with x y}} = name,(x,y)
inl x = { name = "Coord" }

f {x with 
    p = { x = 1
          y = 2 }}


Succ
  "type Tuple0 =
    struct
    val mem_0: int64
    val mem_1: int64
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
and Tuple1 =
    struct
    val mem_0: string
    val mem_1: Tuple0
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
Tuple1("Coord", Tuple0(1L, 2L))
"
test48 - Does the nested module pattern with rebinding work?:
inl f {name {p with y=y' x=x'}} = name,(x',y')
inl x = { name = "Coord" }
f {x with 
    p = { x = 1
          y = 2 }}


Succ
  "type Tuple0 =
    struct
    val mem_0: int64
    val mem_1: int64
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
and Tuple1 =
    struct
    val mem_0: string
    val mem_1: Tuple0
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
Tuple1("Coord", Tuple0(1L, 2L))
"
test49 - Does the lens pattern work? Does self work? Does the semicolon get parsed properly?:
inl x = { a = { b = { c = 3 } } }

inl f {x.a.b with c q} = c,q
f {x.a.b with q = 4; c = self + 3; d = {q = 12; w = 23}}


Succ
  "type Tuple0 =
    struct
    val mem_0: int64
    val mem_1: int64
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
Tuple0(6L, 4L)
"
test50 - Do the Array init and fold work?:
open Array

inl ar = init 6 (inl x -> x+1)
foldl (+) 0 ar, foldr (*) ar 1


Succ
  "type Tuple0 =
    struct
    val mem_0: int64
    val mem_1: int64
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
let rec method_15((var_0: (int64 [])), (var_1: int64)): unit =
    if (var_1 < 6L) then
        var_0.[int32 var_1] <- (var_1 + 1L)
        let (var_2: int64) = (var_1 + 1L)
        method_15((var_0: (int64 [])), (var_2: int64))
    else
        ()
and method_16((var_0: (int64 [])), (var_1: int64), (var_2: int64)): int64 =
    let (var_3: int64) = var_0.LongLength
    if (var_1 < var_3) then
        let (var_4: int64) = (var_1 + 1L)
        let (var_5: int64) = var_0.[int32 var_1]
        let (var_6: int64) = (var_2 + var_5)
        method_16((var_0: (int64 [])), (var_4: int64), (var_6: int64))
    else
        var_2
and method_17((var_0: (int64 [])), (var_1: int64), (var_2: int64)): int64 =
    if (var_1 >= 0L) then
        let (var_3: int64) = (var_1 - 1L)
        let (var_4: int64) = var_0.[int32 var_1]
        let (var_5: int64) = (var_4 * var_2)
        method_17((var_0: (int64 [])), (var_3: int64), (var_5: int64))
    else
        var_2
let (var_0: (int64 [])) = Array.zeroCreate<int64> (System.Convert.ToInt32(6L))
let (var_1: int64) = 0L
method_15((var_0: (int64 [])), (var_1: int64))
let (var_2: int64) = 0L
let (var_3: int64) = 0L
let (var_4: int64) = method_16((var_0: (int64 [])), (var_2: int64), (var_3: int64))
let (var_5: int64) = var_0.LongLength
let (var_6: int64) = (var_5 - 1L)
let (var_7: int64) = 1L
let (var_8: int64) = method_17((var_0: (int64 [])), (var_6: int64), (var_7: int64))
Tuple0(var_4, var_8)
"
test51 - Do the Array map and filter work?:
open Array

inl ar = init 16 id
map ((*) 2) ar
|> filter ((<) 15)


Succ
  "let rec method_15((var_0: (int64 [])), (var_1: int64)): unit =
    if (var_1 < 16L) then
        var_0.[int32 var_1] <- var_1
        let (var_2: int64) = (var_1 + 1L)
        method_15((var_0: (int64 [])), (var_2: int64))
    else
        ()
and method_17((var_0: (int64 [])), (var_1: (int64 [])), (var_2: int64), (var_3: int64)): unit =
    if (var_2 < var_3) then
        let (var_4: int64) = var_1.[int32 var_2]
        var_0.[int32 var_2] <- (2L * var_4)
        let (var_5: int64) = (var_2 + 1L)
        method_17((var_0: (int64 [])), (var_1: (int64 [])), (var_5: int64), (var_3: int64))
    else
        ()
and method_18((var_0: (int64 [])), (var_1: (int64 [])), (var_2: int64), (var_3: int64)): int64 =
    let (var_4: int64) = var_0.LongLength
    if (var_2 < var_4) then
        let (var_5: int64) = (var_2 + 1L)
        let (var_6: int64) = var_0.[int32 var_2]
        let (var_7: int64) =
            if (15L < var_6) then
                var_1.[int32 var_3] <- var_6
                (var_3 + 1L)
            else
                var_3
        method_18((var_0: (int64 [])), (var_1: (int64 [])), (var_5: int64), (var_7: int64))
    else
        var_3
and method_20((var_0: (int64 [])), (var_1: (int64 [])), (var_2: int64), (var_3: int64)): unit =
    if (var_2 < var_3) then
        let (var_4: int64) = var_1.[int32 var_2]
        var_0.[int32 var_2] <- var_4
        let (var_5: int64) = (var_2 + 1L)
        method_20((var_0: (int64 [])), (var_1: (int64 [])), (var_5: int64), (var_3: int64))
    else
        ()
let (var_0: (int64 [])) = Array.zeroCreate<int64> (System.Convert.ToInt32(16L))
let (var_1: int64) = 0L
method_15((var_0: (int64 [])), (var_1: int64))
let (var_2: int64) = var_0.LongLength
let (var_3: bool) = (var_2 >= 0L)
if (var_3 = false) then
    (failwith "The input to init needs to be greater or equal than 0.")
else
    ()
let (var_5: (int64 [])) = Array.zeroCreate<int64> (System.Convert.ToInt32(var_2))
let (var_6: int64) = 0L
method_17((var_5: (int64 [])), (var_0: (int64 [])), (var_6: int64), (var_2: int64))
let (var_7: int64) = var_5.LongLength
let (var_8: (int64 [])) = Array.zeroCreate<int64> (System.Convert.ToInt32(var_7))
let (var_9: int64) = 0L
let (var_10: int64) = 0L
let (var_11: int64) = method_18((var_5: (int64 [])), (var_8: (int64 [])), (var_9: int64), (var_10: int64))
let (var_12: bool) = (var_11 >= 0L)
if (var_12 = false) then
    (failwith "The input to init needs to be greater or equal than 0.")
else
    ()
let (var_14: (int64 [])) = Array.zeroCreate<int64> (System.Convert.ToInt32(var_11))
let (var_15: int64) = 0L
method_20((var_14: (int64 [])), (var_8: (int64 [])), (var_15: int64), (var_11: int64))
var_14
"
test52 - Does the Array concat work?:
open Array

inl ar = init 4 (inl _ -> init 8 id)
concat ar


Succ
  "let rec method_16((var_0: (int64 [])), (var_1: int64)): unit =
    if (var_1 < 8L) then
        var_0.[int32 var_1] <- var_1
        let (var_2: int64) = (var_1 + 1L)
        method_16((var_0: (int64 [])), (var_2: int64))
    else
        ()
and method_17((var_0: ((int64 []) [])), (var_1: int64)): unit =
    if (var_1 < 4L) then
        let (var_2: (int64 [])) = Array.zeroCreate<int64> (System.Convert.ToInt32(8L))
        let (var_3: int64) = 0L
        method_16((var_2: (int64 [])), (var_3: int64))
        var_0.[int32 var_1] <- var_2
        let (var_4: int64) = (var_1 + 1L)
        method_17((var_0: ((int64 []) [])), (var_4: int64))
    else
        ()
and method_18((var_0: ((int64 []) [])), (var_1: int64), (var_2: int64)): int64 =
    let (var_3: int64) = var_0.LongLength
    if (var_1 < var_3) then
        let (var_4: int64) = (var_1 + 1L)
        let (var_5: (int64 [])) = var_0.[int32 var_1]
        let (var_6: int64) = var_5.LongLength
        let (var_7: int64) = (var_2 + var_6)
        method_18((var_0: ((int64 []) [])), (var_4: int64), (var_7: int64))
    else
        var_2
and method_19((var_0: ((int64 []) [])), (var_1: (int64 [])), (var_2: int64), (var_3: int64)): int64 =
    let (var_4: int64) = var_0.LongLength
    if (var_2 < var_4) then
        let (var_5: int64) = (var_2 + 1L)
        let (var_6: (int64 [])) = var_0.[int32 var_2]
        let (var_7: int64) = 0L
        let (var_8: int64) = method_20((var_6: (int64 [])), (var_1: (int64 [])), (var_7: int64), (var_3: int64))
        method_19((var_0: ((int64 []) [])), (var_1: (int64 [])), (var_5: int64), (var_8: int64))
    else
        var_3
and method_20((var_0: (int64 [])), (var_1: (int64 [])), (var_2: int64), (var_3: int64)): int64 =
    let (var_4: int64) = var_0.LongLength
    if (var_2 < var_4) then
        let (var_5: int64) = (var_2 + 1L)
        let (var_6: int64) = var_0.[int32 var_2]
        var_1.[int32 var_3] <- var_6
        let (var_7: int64) = (var_3 + 1L)
        method_20((var_0: (int64 [])), (var_1: (int64 [])), (var_5: int64), (var_7: int64))
    else
        var_3
let (var_2: ((int64 []) [])) = Array.zeroCreate<(int64 [])> (System.Convert.ToInt32(4L))
let (var_3: int64) = 0L
method_17((var_2: ((int64 []) [])), (var_3: int64))
let (var_4: int64) = 0L
let (var_5: int64) = 0L
let (var_6: int64) = method_18((var_2: ((int64 []) [])), (var_4: int64), (var_5: int64))
let (var_7: (int64 [])) = Array.zeroCreate<int64> (System.Convert.ToInt32(var_6))
let (var_8: int64) = 0L
let (var_9: int64) = 0L
let (var_10: int64) = method_19((var_2: ((int64 []) [])), (var_7: (int64 [])), (var_8: int64), (var_9: int64))
var_7
"
test53 - Does the Array append work?:
open Array

inl ar = inl _ -> init 4 id
append (ar (), ar (), ar())


Succ
  "let rec method_15((var_0: (int64 [])), (var_1: int64)): unit =
    if (var_1 < 4L) then
        var_0.[int32 var_1] <- var_1
        let (var_2: int64) = (var_1 + 1L)
        method_15((var_0: (int64 [])), (var_2: int64))
    else
        ()
and method_16((var_0: (int64 [])), (var_1: (int64 [])), (var_2: int64), (var_3: int64)): int64 =
    let (var_4: int64) = var_0.LongLength
    if (var_2 < var_4) then
        let (var_5: int64) = (var_2 + 1L)
        let (var_6: int64) = var_0.[int32 var_2]
        var_1.[int32 var_3] <- var_6
        let (var_7: int64) = (var_3 + 1L)
        method_16((var_0: (int64 [])), (var_1: (int64 [])), (var_5: int64), (var_7: int64))
    else
        var_3
let (var_0: (int64 [])) = Array.zeroCreate<int64> (System.Convert.ToInt32(4L))
let (var_1: int64) = 0L
method_15((var_0: (int64 [])), (var_1: int64))
let (var_2: (int64 [])) = Array.zeroCreate<int64> (System.Convert.ToInt32(4L))
let (var_3: int64) = 0L
method_15((var_2: (int64 [])), (var_3: int64))
let (var_4: (int64 [])) = Array.zeroCreate<int64> (System.Convert.ToInt32(4L))
let (var_5: int64) = 0L
method_15((var_4: (int64 [])), (var_5: int64))
let (var_6: int64) = var_0.LongLength
let (var_7: int64) = (0L + var_6)
let (var_8: int64) = var_2.LongLength
let (var_9: int64) = (var_7 + var_8)
let (var_10: int64) = var_4.LongLength
let (var_11: int64) = (var_9 + var_10)
let (var_12: (int64 [])) = Array.zeroCreate<int64> (System.Convert.ToInt32(var_11))
let (var_13: int64) = 0L
let (var_14: int64) = 0L
let (var_15: int64) = method_16((var_0: (int64 [])), (var_12: (int64 [])), (var_13: int64), (var_14: int64))
let (var_16: int64) = 0L
let (var_17: int64) = method_16((var_2: (int64 [])), (var_12: (int64 [])), (var_16: int64), (var_15: int64))
let (var_18: int64) = 0L
let (var_19: int64) = method_16((var_4: (int64 [])), (var_12: (int64 [])), (var_18: int64), (var_17: int64))
var_12
"
test54 - Does the monadic bind `inm` work?:
inl on_succ a = (a,())
inl on_log x = ((),Tuple.singleton x)
inl (>>=) (a,w) f = // The writer monad.
    inl a',w' = f a
    (a',Tuple.append w w')

inl add x y = x + y |> on_succ

inm x = add 1 1
inm _ = on_log x
inm y = add 3 4
inm _ = on_log y
inm z = add 5 6
inm _ = on_log z
on_succ (x+y+z) // Tuple2(20L, Tuple1(2L, 7L, 11L))


Succ
  "type Tuple0 =
    struct
    val mem_0: int64
    val mem_1: int64
    val mem_2: int64
    new(arg_mem_0, arg_mem_1, arg_mem_2) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1; mem_2 = arg_mem_2}
    end
and Tuple1 =
    struct
    val mem_0: int64
    val mem_1: Tuple0
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
Tuple1(20L, Tuple0(2L, 7L, 11L))
"
test55 - Does the type literal rebind pattern work?:
inl f = .QWE,.66,.2.3
match f with
| .(a), .(b), .(c) -> a,b,c


Succ
  "type Tuple0 =
    struct
    val mem_0: string
    val mem_1: int64
    val mem_2: float
    new(arg_mem_0, arg_mem_1, arg_mem_2) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1; mem_2 = arg_mem_2}
    end
Tuple0("QWE", 66L, 2.300000)
"
test58 - Does the fold function get duplicated?:
inl ar = array_create 128 (int64,int64)
Array.foldl (inl a,b c,d -> a+c,b+d) (dyn (1,2)) ar
|> inl a,b -> a*b


Succ
  "type Tuple0 =
    struct
    val mem_0: int64
    val mem_1: int64
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
let rec method_14((var_0: (Tuple0 [])), (var_1: int64), (var_2: int64), (var_3: int64)): Tuple0 =
    let (var_4: int64) = var_0.LongLength
    if (var_1 < var_4) then
        let (var_5: int64) = (var_1 + 1L)
        let (var_6: Tuple0) = var_0.[int32 var_1]
        let (var_7: int64) = var_6.mem_0
        let (var_8: int64) = var_6.mem_1
        let (var_9: int64) = (var_2 + var_7)
        let (var_10: int64) = (var_3 + var_8)
        method_14((var_0: (Tuple0 [])), (var_5: int64), (var_9: int64), (var_10: int64))
    else
        Tuple0(var_2, var_3)
let (var_0: (Tuple0 [])) = Array.zeroCreate<Tuple0> (System.Convert.ToInt32(128L))
let (var_1: int64) = 1L
let (var_2: int64) = 2L
let (var_3: int64) = 0L
let (var_4: Tuple0) = method_14((var_0: (Tuple0 [])), (var_3: int64), (var_1: int64), (var_2: int64))
let (var_5: int64) = var_4.mem_0
let (var_6: int64) = var_4.mem_1
(var_5 * var_6)
"
test61 - Does dyn act like id on already dyned variables? It should not.:
inl x = dyn false
dyn x || dyn x || dyn x

// The following is in fact the correct behavior. What happens is that x gets assumed to be true or false
// in one of the branches and then rewritten before being passed into dyn again and turned into a new variable.

//let (var_16: bool) = false
//if var_16 then
//    true
//else
//    let (var_17: bool) = false
//    if var_17 then
//        true
//    else
//        false


Succ
  "let (var_0: bool) = false
if var_0 then
    true
else
    let (var_1: bool) = false
    if var_1 then
        true
    else
        false

"
test62 - Do && and || work correctly?:
inl a,b,c,d,e = dyn (true, false, true, false, true)
met f x = x
f a && f b || f c && f d || f e


Succ
  "let rec method_14((var_0: bool)): bool =
    var_0
let (var_0: bool) = true
let (var_1: bool) = false
let (var_2: bool) = true
let (var_3: bool) = false
let (var_4: bool) = true
let (var_5: bool) = method_14((var_0: bool))
let (var_7: bool) =
    if var_5 then
        method_14((var_1: bool))
    else
        false
if var_7 then
    true
else
    let (var_8: bool) = method_14((var_2: bool))
    let (var_10: bool) =
        if var_8 then
            method_14((var_3: bool))
        else
            false
    if var_10 then
        true
    else
        method_14((var_4: bool))

"
test63 - Do the list constructors work?:
open List
cons 1 (cons 2 (singleton 3))


Succ
  "type Rec0 =
    | Rec0Case0
    | Rec0Case1 of Tuple1
and Tuple1 =
    struct
    val mem_0: int64
    val mem_1: Rec0
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
Rec0Case1(Tuple1(1L, Rec0Case1(Tuple1(2L, Rec0Case1(Tuple1(3L, Rec0Case0))))))
"
test64 - Does the list pattern work?:
open List

match dyn (empty int64) with
| #lw (a,b) -> a + b + 10
| #lw (x :: x2 :: xs) -> x + x2
| #lw (x :: xs) -> 55
| #lw () -> 0
| _ -> 1 // Does not get triggered.


Succ
  "type Rec0 =
    | Rec0Case0
    | Rec0Case1 of Tuple1
and Tuple1 =
    struct
    val mem_0: int64
    val mem_1: Rec0
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
let (var_0: Rec0) = Rec0Case0
match var_0 with
| Rec0Case0 ->
    0L
| Rec0Case1(var_2) ->
    let (var_3: int64) = var_2.mem_0
    let (var_4: Rec0) = var_2.mem_1
    match var_4 with
    | Rec0Case0 ->
        55L
    | Rec0Case1(var_6) ->
        let (var_7: int64) = var_6.mem_0
        let (var_8: Rec0) = var_6.mem_1
        match var_8 with
        | Rec0Case0 ->
            let (var_11: int64) = (var_3 + var_7)
            (var_11 + 10L)
        | Rec0Case1(var_10) ->
            let (var_12: int64) = var_10.mem_0
            let (var_13: Rec0) = var_10.mem_1
            (var_3 + var_7)

"
test65 - Do the list module folds work?:
open List

foldl (+) 0.0 (dyn (empty float64)),
foldr (+) (dyn (empty float64)) 0.0f64


Succ
  "type Rec0 =
    | Rec0Case0
    | Rec0Case1 of Tuple2
and Tuple1 =
    struct
    val mem_0: float
    val mem_1: float
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
and Tuple2 =
    struct
    val mem_0: float
    val mem_1: Rec0
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
let rec method_18((var_0: Rec0), (var_1: float)): float =
    match var_0 with
    | Rec0Case0 ->
        var_1
    | Rec0Case1(var_3) ->
        let (var_4: float) = var_3.mem_0
        let (var_5: Rec0) = var_3.mem_1
        let (var_6: float) = (var_1 + var_4)
        method_18((var_5: Rec0), (var_6: float))
and method_19((var_0: Rec0), (var_1: float)): float =
    match var_0 with
    | Rec0Case0 ->
        var_1
    | Rec0Case1(var_3) ->
        let (var_4: float) = var_3.mem_0
        let (var_5: Rec0) = var_3.mem_1
        let (var_6: float) = method_19((var_5: Rec0), (var_1: float))
        (var_4 + var_6)
let (var_0: Rec0) = Rec0Case0
let (var_1: float) = 0.000000
let (var_2: float) = method_18((var_0: Rec0), (var_1: float))
let (var_3: Rec0) = Rec0Case0
let (var_4: float) = 0.000000
let (var_5: float) = method_19((var_3: Rec0), (var_4: float))
Tuple1(var_2, var_5)
"
test66 - Does the list module concat (and by extension append) work?:
open List

inl a = cons 3 () |> cons 2 |> cons 1 |> dyn
inl b = cons 6 () |> cons 5 |> cons 4 |> dyn
inl c = dyn (cons a (singleton b))
concat c


Succ
  "type Rec0 =
    | Rec0Case0
    | Rec0Case1 of Tuple3
and Rec1 =
    | Rec1Case0
    | Rec1Case1 of Tuple2
and Tuple2 =
    struct
    val mem_0: int64
    val mem_1: Rec1
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
and Tuple3 =
    struct
    val mem_0: Rec1
    val mem_1: Rec0
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
let rec method_22((var_0: Rec0), (var_1: Rec1)): Rec1 =
    match var_0 with
    | Rec0Case0 ->
        var_1
    | Rec0Case1(var_3) ->
        let (var_4: Rec1) = var_3.mem_0
        let (var_5: Rec0) = var_3.mem_1
        let (var_6: Rec1) = method_22((var_5: Rec0), (var_1: Rec1))
        method_23((var_4: Rec1), (var_6: Rec1))
and method_23((var_0: Rec1), (var_1: Rec1)): Rec1 =
    match var_0 with
    | Rec1Case0 ->
        var_1
    | Rec1Case1(var_3) ->
        let (var_4: int64) = var_3.mem_0
        let (var_5: Rec1) = var_3.mem_1
        let (var_6: Rec1) = method_23((var_5: Rec1), (var_1: Rec1))
        Rec1Case1(Tuple2(var_4, var_6))
let (var_0: Rec1) = Rec1Case1(Tuple2(1L, Rec1Case1(Tuple2(2L, Rec1Case1(Tuple2(3L, Rec1Case0))))))
let (var_1: Rec1) = Rec1Case1(Tuple2(4L, Rec1Case1(Tuple2(5L, Rec1Case1(Tuple2(6L, Rec1Case0))))))
let (var_2: Rec0) = Rec0Case1(Tuple3(var_0, Rec0Case1(Tuple3(var_1, Rec0Case0))))
let (var_3: Rec1) = Rec1Case0
method_22((var_2: Rec0), (var_3: Rec1))
"
test67 - Does the list module map work?:
open List

inl a = cons 3 () |> cons 2 |> cons 1 |> dyn

map ((*) 2) a


Succ
  "type Rec0 =
    | Rec0Case0
    | Rec0Case1 of Tuple1
and Tuple1 =
    struct
    val mem_0: int64
    val mem_1: Rec0
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
let rec method_19((var_0: Rec0)): Rec0 =
    match var_0 with
    | Rec0Case0 ->
        Rec0Case0
    | Rec0Case1(var_2) ->
        let (var_3: int64) = var_2.mem_0
        let (var_4: Rec0) = var_2.mem_1
        let (var_5: int64) = (2L * var_3)
        let (var_6: Rec0) = method_19((var_4: Rec0))
        Rec0Case1(Tuple1(var_5, var_6))
let (var_0: Rec0) = Rec0Case1(Tuple1(1L, Rec0Case1(Tuple1(2L, Rec0Case1(Tuple1(3L, Rec0Case0))))))
method_19((var_0: Rec0))
"
test68 - Is it possible to make a list of lists?:
open List

inl a = empty int64 |> dyn
empty a


Succ
  "type Rec0 =
    | Rec0Case0
    | Rec0Case1 of Tuple2
and Rec1 =
    | Rec1Case0
    | Rec1Case1 of Tuple3
and Tuple2 =
    struct
    val mem_0: int64
    val mem_1: Rec0
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
and Tuple3 =
    struct
    val mem_0: Rec0
    val mem_1: Rec1
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
let (var_0: Rec0) = Rec0Case0
Rec1Case0
"
test69 - Does the list module init work?:
open List

init 10 (inl x -> 2.2)


Succ
  "type Rec0 =
    | Rec0Case0
    | Rec0Case1 of Tuple1
and Tuple1 =
    struct
    val mem_0: float
    val mem_1: Rec0
    new(arg_mem_0, arg_mem_1) = {mem_0 = arg_mem_0; mem_1 = arg_mem_1}
    end
let rec method_15((var_0: int64)): Rec0 =
    if (var_0 < 10L) then
        let (var_1: int64) = (var_0 + 1L)
        let (var_2: Rec0) = method_15((var_1: int64))
        Rec0Case1(Tuple1(2.200000, var_2))
    else
        Rec0Case0
let (var_0: int64) = 0L
method_15((var_0: int64))
"
hacker_rank_1 - The very first warmup exercise : https://www.hackerrank.com/challenges/solve-me-first:
inl console = ."System.Console" |> mscorlib
inl parse_int32 = 
    inl f = ."System.Int32" |> mscorlib
    inl str -> f .Parse str
inl read_line () = console.ReadLine()
inl write x = console.Write x
inl read_int () = read_line() |> parse_int32
inl a, b = read_int(), read_int()
write (a + b)


Succ
  "let (var_0: string) = System.Console.ReadLine()
let (var_1: int32) = System.Int32.Parse(var_0)
let (var_2: string) = System.Console.ReadLine()
let (var_3: int32) = System.Int32.Parse(var_2)
let (var_4: int32) = (var_1 + var_3)
System.Console.Write(var_4)

"
parsing1 - Does the Parsing module work?:
open Parsing
open Console

inl p = 
    succ 1
    |>> writeline

run_with_unit_ret (readall()) p


Succ
  "let (var_0: System.IO.Stream) = System.Console.OpenStandardInput()
let (var_1: System.IO.StreamReader) = System.IO.StreamReader(var_0)
let (var_2: string) = var_1.ReadToEnd()
System.Console.WriteLine(1L)
let (var_3: int64) = 0L

"
parsing2 - Does the Parsing module work?:
open Parsing
open Console

inl p = 
    pdigit
    |>> writeline

run_with_unit_ret (readall()) p


Succ
  "let (var_0: System.IO.Stream) = System.Console.OpenStandardInput()
let (var_1: System.IO.StreamReader) = System.IO.StreamReader(var_0)
let (var_2: string) = var_1.ReadToEnd()
let (var_3: int64) = 0L
let (var_5: bool) =
    if (var_3 >= 0L) then
        let (var_4: int64) = (int64 var_2.Length)
        (var_3 < var_4)
    else
        false
if var_5 then
    let (var_6: char) = var_2.[int32 var_3]
    let (var_7: bool) =
        if (var_6 >= '0') then
            (var_6 <= '9')
        else
            false
    let (var_8: int64) = (var_3 + 1L)
    if var_7 then
        System.Console.WriteLine(var_6)
    else
        (failwith "digit")
else
    (failwith "string index out of bounds")

"
parsing3 - Does the Parsing module work?:
open Parsing
open Console

inl p = 
    pstring "qwe"
    |>> writeline

run_with_unit_ret (readall()) p


Succ
  "let rec method_14((var_0: string), (var_1: int64), (var_2: string), (var_3: int64)): unit =
    let (var_4: int64) = (int64 var_2.Length)
    let (var_5: bool) = (var_1 < var_4)
    if var_5 then
        let (var_6: char) = var_2.[int32 var_1]
        let (var_7: int64) = (var_1 + 1L)
        let (var_9: bool) =
            if (var_3 >= 0L) then
                let (var_8: int64) = (int64 var_0.Length)
                (var_3 < var_8)
            else
                false
        if var_9 then
            let (var_10: char) = var_0.[int32 var_3]
            let (var_11: bool) = (var_6 = var_10)
            let (var_12: int64) = (var_3 + 1L)
            if var_11 then
                method_14((var_0: string), (var_7: int64), (var_2: string), (var_12: int64))
            else
                (failwith "char")
        else
            (failwith "string index out of bounds")
    else
        System.Console.WriteLine(var_2)
let (var_0: string) = "qwe"
let (var_1: System.IO.Stream) = System.Console.OpenStandardInput()
let (var_2: System.IO.StreamReader) = System.IO.StreamReader(var_1)
let (var_3: string) = var_2.ReadToEnd()
let (var_4: int64) = 0L
let (var_5: int64) = 0L
method_14((var_3: string), (var_4: int64), (var_0: string), (var_5: int64))

"
parsing4 - Does the Parsing module work?:
open Parsing
open Console

inl p = 
    parse_int
    |>> writeline

run_with_unit_ret (readall()) p


Succ
  "let rec method_14((var_0: bool), (var_1: string), (var_2: int64)): unit =
    let (var_4: bool) =
        if (var_2 >= 0L) then
            let (var_3: int64) = (int64 var_1.Length)
            (var_2 < var_3)
        else
            false
    if var_4 then
        let (var_5: char) = var_1.[int32 var_2]
        let (var_6: bool) =
            if (var_5 >= '0') then
                (var_5 <= '9')
            else
                false
        let (var_7: int64) = (var_2 + 1L)
        if var_6 then
            let (var_8: int64) = System.Convert.ToInt64(var_5)
            let (var_9: int64) = System.Convert.ToInt64('0')
            let (var_10: int64) = (var_8 - var_9)
            let (var_11: int64) = (0L + var_10)
            method_15((var_0: bool), (var_1: string), (var_11: int64), (var_7: int64))
        else
            (failwith "pint64")
    else
        (failwith "pint64")
and method_15((var_0: bool), (var_1: string), (var_2: int64), (var_3: int64)): unit =
    let (var_5: bool) =
        if (var_3 >= 0L) then
            let (var_4: int64) = (int64 var_1.Length)
            (var_3 < var_4)
        else
            false
    if var_5 then
        let (var_6: char) = var_1.[int32 var_3]
        let (var_7: bool) =
            if (var_6 >= '0') then
                (var_6 <= '9')
            else
                false
        let (var_8: int64) = (var_3 + 1L)
        if var_7 then
            let (var_9: int64) = System.Convert.ToInt64(var_6)
            let (var_10: int64) = System.Convert.ToInt64('0')
            let (var_11: int64) = (var_9 - var_10)
            let (var_12: bool) =
                if (var_2 = 922337203685477580L) then
                    (var_11 <= 7L)
                else
                    false
            let (var_13: bool) =
                if var_12 then
                    true
                else
                    (var_2 < 922337203685477580L)
            if var_13 then
                let (var_14: int64) = (var_2 * 10L)
                let (var_15: int64) = (var_14 + var_11)
                method_15((var_0: bool), (var_1: string), (var_15: int64), (var_8: int64))
            else
                (failwith "integer overflow")
        else
            let (var_16: int64) =
                if var_0 then
                    var_2
                else
                    (-var_2)
            let (var_17: int64) = 0L
            method_16((var_16: int64), (var_1: string), (var_17: int64), (var_8: int64))
    else
        let (var_18: int64) =
            if var_0 then
                var_2
            else
                (-var_2)
        let (var_19: int64) = 0L
        method_16((var_18: int64), (var_1: string), (var_19: int64), (var_3: int64))
and method_16((var_0: int64), (var_1: string), (var_2: int64), (var_3: int64)): unit =
    let (var_4: int64) = (var_2 + 1L)
    let (var_6: bool) =
        if (var_3 >= 0L) then
            let (var_5: int64) = (int64 var_1.Length)
            (var_3 < var_5)
        else
            false
    if var_6 then
        let (var_7: char) = var_1.[int32 var_3]
        let (var_9: bool) =
            if (var_7 = ' ') then
                true
            else
                if (var_7 = '\n') then
                    true
                else
                    (var_7 = '\r')
        let (var_10: int64) = (var_3 + 1L)
        if var_9 then
            method_16((var_0: int64), (var_1: string), (var_4: int64), (var_10: int64))
        else
            System.Console.WriteLine(var_0)
    else
        System.Console.WriteLine(var_0)
let (var_0: System.IO.Stream) = System.Console.OpenStandardInput()
let (var_1: System.IO.StreamReader) = System.IO.StreamReader(var_0)
let (var_2: string) = var_1.ReadToEnd()
let (var_3: int64) = 0L
let (var_5: bool) =
    if (var_3 >= 0L) then
        let (var_4: int64) = (int64 var_2.Length)
        (var_3 < var_4)
    else
        false
if var_5 then
    let (var_6: char) = var_2.[int32 var_3]
    let (var_7: bool) = ('-' = var_6)
    let (var_8: int64) = (var_3 + 1L)
    if var_7 then
        let (var_9: bool) = false
        method_14((var_9: bool), (var_2: string), (var_8: int64))
    else
        let (var_10: bool) = true
        method_14((var_10: bool), (var_2: string), (var_8: int64))
else
    let (var_11: bool) = true
    method_14((var_11: bool), (var_2: string), (var_3: int64))

"
parsing5 - Does the Parsing module work?:
open Parsing
open Console

inl p = 
    parse_n_array parse_int 16
    |>> writeline

run_with_unit_ret (readall()) p


Succ
  "let rec method_25((var_0: (int64 [])), (var_1: string), (var_2: int64), (var_3: int64)): unit =
    let (var_4: bool) = (var_2 < 16L)
    if var_4 then
        let (var_6: bool) =
            if (var_3 >= 0L) then
                let (var_5: int64) = (int64 var_1.Length)
                (var_3 < var_5)
            else
                false
        if var_6 then
            let (var_7: char) = var_1.[int32 var_3]
            let (var_8: bool) = ('-' = var_7)
            let (var_9: int64) = (var_3 + 1L)
            if var_8 then
                let (var_10: bool) = false
                method_26((var_10: bool), (var_0: (int64 [])), (var_2: int64), (var_1: string), (var_9: int64))
            else
                let (var_11: bool) = true
                method_26((var_11: bool), (var_0: (int64 [])), (var_2: int64), (var_1: string), (var_9: int64))
        else
            let (var_12: bool) = true
            method_26((var_12: bool), (var_0: (int64 [])), (var_2: int64), (var_1: string), (var_3: int64))
    else
        System.Console.WriteLine(var_0)
and method_26((var_0: bool), (var_1: (int64 [])), (var_2: int64), (var_3: string), (var_4: int64)): unit =
    let (var_6: bool) =
        if (var_4 >= 0L) then
            let (var_5: int64) = (int64 var_3.Length)
            (var_4 < var_5)
        else
            false
    if var_6 then
        let (var_7: char) = var_3.[int32 var_4]
        let (var_8: bool) =
            if (var_7 >= '0') then
                (var_7 <= '9')
            else
                false
        let (var_9: int64) = (var_4 + 1L)
        if var_8 then
            let (var_10: int64) = System.Convert.ToInt64(var_7)
            let (var_11: int64) = System.Convert.ToInt64('0')
            let (var_12: int64) = (var_10 - var_11)
            let (var_13: int64) = (0L + var_12)
            method_27((var_0: bool), (var_1: (int64 [])), (var_2: int64), (var_3: string), (var_13: int64), (var_9: int64))
        else
            (failwith "pint64")
    else
        (failwith "pint64")
and method_27((var_0: bool), (var_1: (int64 [])), (var_2: int64), (var_3: string), (var_4: int64), (var_5: int64)): unit =
    let (var_7: bool) =
        if (var_5 >= 0L) then
            let (var_6: int64) = (int64 var_3.Length)
            (var_5 < var_6)
        else
            false
    if var_7 then
        let (var_8: char) = var_3.[int32 var_5]
        let (var_9: bool) =
            if (var_8 >= '0') then
                (var_8 <= '9')
            else
                false
        let (var_10: int64) = (var_5 + 1L)
        if var_9 then
            let (var_11: int64) = System.Convert.ToInt64(var_8)
            let (var_12: int64) = System.Convert.ToInt64('0')
            let (var_13: int64) = (var_11 - var_12)
            let (var_14: bool) =
                if (var_4 = 922337203685477580L) then
                    (var_13 <= 7L)
                else
                    false
            let (var_15: bool) =
                if var_14 then
                    true
                else
                    (var_4 < 922337203685477580L)
            if var_15 then
                let (var_16: int64) = (var_4 * 10L)
                let (var_17: int64) = (var_16 + var_13)
                method_27((var_0: bool), (var_1: (int64 [])), (var_2: int64), (var_3: string), (var_17: int64), (var_10: int64))
            else
                (failwith "integer overflow")
        else
            let (var_18: int64) =
                if var_0 then
                    var_4
                else
                    (-var_4)
            let (var_19: int64) = 0L
            method_28((var_18: int64), (var_1: (int64 [])), (var_2: int64), (var_3: string), (var_19: int64), (var_10: int64))
    else
        let (var_20: int64) =
            if var_0 then
                var_4
            else
                (-var_4)
        let (var_21: int64) = 0L
        method_28((var_20: int64), (var_1: (int64 [])), (var_2: int64), (var_3: string), (var_21: int64), (var_5: int64))
and method_28((var_0: int64), (var_1: (int64 [])), (var_2: int64), (var_3: string), (var_4: int64), (var_5: int64)): unit =
    let (var_6: int64) = (var_4 + 1L)
    let (var_8: bool) =
        if (var_5 >= 0L) then
            let (var_7: int64) = (int64 var_3.Length)
            (var_5 < var_7)
        else
            false
    if var_8 then
        let (var_9: char) = var_3.[int32 var_5]
        let (var_11: bool) =
            if (var_9 = ' ') then
                true
            else
                if (var_9 = '\n') then
                    true
                else
                    (var_9 = '\r')
        let (var_12: int64) = (var_5 + 1L)
        if var_11 then
            method_28((var_0: int64), (var_1: (int64 [])), (var_2: int64), (var_3: string), (var_6: int64), (var_12: int64))
        else
            var_1.[int32 var_2] <- var_0
            let (var_13: int64) = (var_2 + 1L)
            method_25((var_1: (int64 [])), (var_3: string), (var_13: int64), (var_12: int64))
    else
        var_1.[int32 var_2] <- var_0
        let (var_14: int64) = (var_2 + 1L)
        method_25((var_1: (int64 [])), (var_3: string), (var_14: int64), (var_5: int64))
let (var_0: System.IO.Stream) = System.Console.OpenStandardInput()
let (var_1: System.IO.StreamReader) = System.IO.StreamReader(var_0)
let (var_2: string) = var_1.ReadToEnd()
let (var_3: int64) = 0L
let (var_7: (int64 [])) = Array.zeroCreate<int64> (System.Convert.ToInt32(16L))
let (var_8: int64) = 0L
method_25((var_7: (int64 [])), (var_2: string), (var_8: int64), (var_3: int64))

"
parsing6 - Do the printf's work?:
open Parsing
open Console

inl a,b,c = dyn (1,2,3)
sprintf "%i + %i = %i" a b c |> ignore
printfn "(%i,%i,%i)" a b c


Succ
  "let (var_0: int64) = 1L
let (var_1: int64) = 2L
let (var_2: int64) = 3L
let (var_3: System.Text.StringBuilder) = System.Text.StringBuilder(64)
let (var_4: System.Text.StringBuilder) = var_3.Append(var_0)
let (var_5: System.Text.StringBuilder) = var_3.Append(" + ")
let (var_6: System.Text.StringBuilder) = var_3.Append(var_1)
let (var_7: System.Text.StringBuilder) = var_3.Append(" = ")
let (var_8: System.Text.StringBuilder) = var_3.Append(var_2)
let (var_9: string) = var_3.ToString()
System.Console.Write("(")
System.Console.Write(var_0)
System.Console.Write(",")
System.Console.Write(var_1)
System.Console.Write(",")
System.Console.Write(var_2)
System.Console.Write(")")
System.Console.WriteLine()

"
